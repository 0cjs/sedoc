- [README](README.md), [asm](asm.md), [opcodes](opcodes.md),
  [progcard](progcard)

6800 Assembler Syntax
=====================

Architecture
------------

See end of this document for 6801/03 architecture differences.

Single 16-bit 64K address space for memory and I/O. Shorter _direct
addressing_ available for addresses $00-$FF.

### Registers and Flags

- `A`, `B` (8): Accumulators. Also `ACCA`/`ACCB`/`ACCX` (either).
- `X` (16): 16-bit Index register, also `IX`
- `SP` (16): Stack pointer (grows down) to next "empty" location
- `PC` (16): Program counter
- Condition codes or processor status byte: `11HINZVC`

      1  Always 1 on read; ignored by by TAP, RTI, etc.
      H   Half carry: set on b3→b4 carry for ADD, ABA, ADC
      I   Interrupt mask; IRQ masked when set.
      N   Negative: high order bit of result
      Z   Zero: checked result == 0
      V   Overflow
      C   Carry-borrow (carry for add; borrow for subtract).

The 6800/6802 have no `D` view of `A` and `B` together, but later
processors do.

### Stack and Subroutines

- Stack grows down, points to empty location below most recent push.
- Only A and B can be pushed/pulled directly.
- `TSX`/`TXS` xfer pointer to end of stack, not SP pointing below end;
  i.e. `TSX: X←SP+1` and `TXS: SP←X-1`
- `BSR`/`JSR` push PC to be used by `RTS`.

When manipulating stack via `X` remember that it may be changed by
interrupts during the process.

### Interrupts

Generated by NMI and IRQ inputs are held until the following instruction is
ready to start or, if signaled on the last cycle of an instruction, until
the following instruction completes. `SWI` executes the interrupt routine
on completion. Vectors are:

    $FFF8  IRQ      $FFFA  SWI      $FFFC  NMI      $FFFE  Reset

On interrupt or on `WAI` instruction the PC is set to the next address
after the instruction that just finished, the registers are pushed per
below, and the `I` flag is set for IRQ and `SWI` response.

    CC ACCA ACCB IXH IXL PCH PCL ___
    downward →                    └── SP points here


Instruction Set
---------------

#### General Notes

- Both 2s-complement `NEG` and 1s-complement `COM` available.
- `COMA` sets carry; `EORA $FF` does not.
- `LDAA $1234` can test memory w/o clearing carry like `TST $1234`.
- `CLR`/`CLRA`/`CLRB` to zero mem/reg clears carry; `LDAA #0` does not.
- `INC`/`DEC` do not affect carry.
- 8-bit rotate: `ASLA` / `BCC *+3` / `INCA`.
- Signed uses V-bit branches (`BGT`), unsigned ignores V-bit (`BHI`).
- `CPX` doesn't work w/all branches until 6801.

#### Addressing Modes

Motorola assemblers use _dual addressing_ for accumulator ops that take an
operand, `ADD A,#3`; many other assemblers use `ADDA #3`. No-operand
_accumulator addressing_ may be done either way in Motorola assemblers,
`PSH A` or `PSHA`.

- _Inherent_: No operands; specified by instruction itself.
- _Immediate_: `#arg`. 16 bits for `CPX`, `LDS`, `LDX`; 8 for others.
- _Relative_: Signed 8-bit offset from start of next instruction. Unique to
  branch instructions, which have no other addressing modes.
- _Indexed_: `X`, `,X`, `n,X`. Add unsigned one-byte offset _n_ (assembler
  inserts 0 by default) to contents of X to produce address.
- _Extended_: Opcode followed by MSB and LSB of address.
- _Direct_: Opcode followed by LSB of address; MSB = 0.

#### Branch tests

- Single Flag:
  - Zero: `BEQ` `BNE`
  - Negative: `BMI` `BPL`
  - Carry: `BCS` `BCC`
  - oVerflow: `BVS` `BVC`
- Multi-flag comparison results:
  - Unsigned: `BLS` (less-than/same) `BHI`
  - Two's complement: `BLT` `BLE` `BGE` `BGT`

Motorola Assembler Syntax
-------------------------

Also see "Addressing Modes" above.

Value annotations:
- `97`: decimal
- `$61`: hexadecimal
- `%01100001`: binary
- `'a`: 7-bit ASCII character; `a` must be $20-$5F
- `@171`: octal
- `*`: current location
- `#$0C`: operand for immediate addressing mode

The [Motorola assembler][masm] always uses extended (two byte)
addressing mode for forward references, but will choose the shorter of
extended or direct (one-byte) for backward references.

Relative addresses (for `BRA` etc.) are -128 through +127 from the
location of the following instruction, i.e., `BRA` to a relative
address of zero executes the next instruction.


6801/03 Extensions over 6800/02
-----------------------------------

- 6801/03 changes some instruction timings.
- "D" register is concatenation of A, B.
- Complete [6801/03 instruction table][6801inst]

    D register:
      LDD, STD
      ADDD          D ← D + mem, no carry
      SUBD          D ← D - mem
      ASLD/LSLD     LSB ← 0, Carry ← MSB
      LSRD          MSB ← 0, Carry ← LSB
      LSL           Same as ASL (memory or either accumulator)
    X register:
      ABX           B ← X + B
      PSHX, PULX
    Branches:
      BHS       Branch higher or same, = BCC
      BLO       Branch lower, = BCS
      BRN       Branch never
      JSR       Additional direct (1-byte operand) addressing mode.
    Miscellaneous:
      MUL       D ← A * B (unsigned)
      CPX       Compare X now works with any conditional branch instr.



<!-------------------------------------------------------------------->
[6801inst]: https://archive.org/stream/bitsavers_motorola68ReferenceManualMay84_19173732#page/n98/mode/1up
[masm]: https://archive.org/details/bitsavers_motorola68ReferenceManualMay84_19173732/page/n91
