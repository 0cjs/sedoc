Nix Package Manager
===================

[NixOS] is a Linux distribution that uses the [Nix] package manager and the
[Nixpkgs] channel. However, Nix itself requires neither of these and can be
used standalone on any Linux distro or MacOS.


Installation
------------

* __Debian:__ `apt-get install nix-bin` and add yourself to the `nix-users`
  group. (The `nix-setup-systemd` package for the Nix daemon will be
  included as a recommendation unless you specifically exclude it.)
* __Arch:__ `nix` and `archlinux-nix` packages available, but seems to
  require [some manual configuration][arch].
* __Vendor:__ [Binary install][nix instbin] typically via `sh <(curl -L
  https://nixos.org/nix/install) --daemon`, or [build from source][nix
  instsrc]

Individual scripts may use nix via [`nix-shell` hashbang][nix #!] to
build an environment for the script:

    #!/usr/bin/env nix-shell
    #!nix-shell -i real-interpreter -p packages


Overview
--------

Paths:

    /nix/store/             object store
    /nix/var/nix/profiles/  profile symlinks into /nix/store/*-environment
    ~/.nix-profile          symlink to current environment
    ~/.nix-channels         file listing channels
    ~/.nix-defexpr/         (see nix-env(1) manpage)

Most Nix package-related information outside `/nix/store/` is just symlinks
into that object store. In a "multi-user" configuration all changes to
`/nix/` are handled by the Nix daemon, which also has its own user IDs for
building things. Nix can also be used in a "single-user" configuration
where `/nix/` is owned by a user.

Nix packages and anything else generated by a build action (including
downloaded source, intermediate build products, profiles, channel
information, etc.) are the _outputs_ of a Nix object called a _derivation_
Derivations themselves are outputs (`.drv` files) from evaluating
_expressions_ in the pure, lazy, functional [Nix expression language][nix expr]. (Expressions themselves may also be outputs stored in `.nix` files.)
All outputs are stored in _store paths_ under under `/nix/store/`, named by
a hash determined by the inputs followed by a (human-readable) symbolic
name.

Outputs are _realised_ by either building everything necessary to realise
the path or, when available, fetching a _substitute_, an already-built
version of the output for that particular platform. See the `nix-store
--realise` command for more details.

Subsitutes may come from the following sources:
- Binaries distributed with [channels] (XXX how do those work?).
- A ["binary cache"][bc] made available via `nix-serve` by any machine from
  its own Nix store (populated via local builds or `nix copy`).
- A dedicated cache server such as [Cachix].

#### Files and Directories in the Store

Entries under `/nix/store` are _content indexed_ using a _HASH_ prefix on
each entry. Because this is a hash of the entry's contents, it is unique
within the store and not be related to the hash for any other entry. (Links
to other entries are made via information within the entry.)

In the `/nix/store/`, the following patterns are seen:

Build-related files:
- `HASH-PNAME-PVER.drv` files are (compiled?) derivation expressions for
  one or more packages. Subscribing to a channel will copy all of its
  `.drv` files to the store. (Actually, these are maybe created by
  `nix-instantiate` from the package's `.nix` files?)
- Loose files ending in `.sh`, `.toml`, `.patch`, etc., also copied from
  channels. These appear to be additional files such as custom builders
  that are part of a package expression/description; they're referenced in
  `.drv` files.

Packages:
- `HASH-PNAME-PVER/` is the directory for a built/installed package. A
  `.drv` file will list at least one of these as an output package. (More
  than one output may be generated, e.g., `*-cowsay-3.04` and
  `*-cowsay-3.04-man`.)

Environments (see "Environment" section below for details):
- `HASH-env-manifest.nix`
- `HASH-user-environment.drv`
- `HASH-user-environment/`
- `HASH-user-environment/manifest.nix`: symlink to original `.nix` above

### Environments

An _environment_ is a locally-generated package (a directory under
`/nix/store/`) that contains symlinks to other packages and files under
`/nix/store/`. These are used for profiles and sets of subscribed channels,
both described in later sections.

An environment is created in three steps:
1. `nix-env --install` or similar generates `HASH-env-manifest.nix`
   containing a Nix expression describing the environment This is a list of
   sets, each set describing a Nix package included in the environment,
   including the package name, system, output path under `/nix/store/` and
   package metadata.
2. `HASH-user-environment.drv`: A _[derivation]_ compiled from the
   expression above.
3. `HASH-user-environment/`: the _output_, a package built from the above
   derivation. At the top level will be a `manifest.nix` symlink to the
   original `HASH-env-manifest.nix` above.

### Profiles

A profile environment provides a standard Unix $PREFIX hierarchy
(`bin/`, `share/`, etc.) giving a synthesized view of a subset of packages
in the whole store. This view includes filename priority, usually
determined by the order in which packages were installed, so an environment
with A then B installed is different from an environment with B then A
installed. Environments will be re-used if a sequence of install commands
produces the same environment as one that already exists.

A _profile_ is a name for a set of environments called _generations_ of
that profile, one of which is the _current generation_. The generations
have no relationship to each other; if the higest generation number is _M_:
any command that creates a new environment always assigns generation _M+1_
regardless of the current generation and `nix-env --rollback` always
switches to the highest generation less than _M_, regardless of what the
previous generation actually was. Thus, if the highest generation number is
6, switching from 5 to 3 and installing a package will take you to
generation 7, and rollback will take you to 6, not 3.

Profiles are implemented as a naming and symlinking convention. Profile
`PNAME` is a symlink to a generation `PNAME-1-link`, which in turn is a
symlink to an environment `/nix/store/...-user-environment/` which contains
the hierarchy. The _active profile_ is the one currently being operated on
(the current profile below or specified with `-p PATH`).

`~/.nix-profile` is a symlink indicating the _current profile_, which is
used when `-p PATH` is not specified. The user typically will add
`~/.nix-profile/bin/` to his $PATH.

With no current profile, profile modification commands will create a new
profile `/nix/var/nix/profiles/per-user/USER/profile` and set the current
profile to that. That directory is owned by _USER_ and is special in that
profiles there are used as roots for the garbage collector. (See below for
more on GC roots.) However, that path is not a default prefix for
`nix-env`; the full path to profiles in that directory must still be given
to `-p`.

Links to channel environments are also stored under the profile directory;
see below for more details.

### Channels

    nix-channel --list
    nix-channel --update [NAME ...]
    nix-channel --rollback          # "reverts last --update," but probably
                                    #    actually 2nd highest seq. no. XXX
    nix-channel --add URL NAME      # doesn't d/l exprs; use --update after
    nix-channel --remove NAME

A set of subscribed [channels] is stored as an environment under the usual
`/nix/store/HASH-user-environment/` naming scheme. (This _HASH_ is, as
usual, the content hash and not the same as any hashes in symlinks within
the environment package.) This will have a `manifest.nix` symlink to a
`/nix/store/HASH-env-manifest.nix` file containing information about the
channels and a symlink for each user-assigned channel name.

After assocating a channel name to a tarball with `nix-channel --add`,
`--update` creates a new local package with a subdirectory, both  named for
that channel: `/nix/store/HASH-CHAN/CHAN/`; this subdirectory is the target
of the link in the environment above. The contents of the tarball, after
dropping the tarball's top-level directory, are unpacked under that so that
`/*/default.nix` file from the tarball will be in
`/nix/store/HASH-CHAN/CHAN/default.nix`.

See [Luc Perkins' blog post][lucperkins] for a tutorial on creating a
channel and making its tarball automatically available via GitHub archives.

### Garbage Collection and GC Roots

Roots for GC are under `/nix/var/nix/gcroots/`, the profiles directories
(which includes channel subscriptions), and perhaps others. GC operations:

    nix-store --gc --print-roots        # show dirs scanned for GC roots
    nix-store --gc --print-live         # show what would be kept
    nix-store --gc --print-dead         # show what would be deleted
    nix-store --gc --print-delete       # default; perform GC
    nix-store --delete PATH             # deletes only if not live

`--max-freed BYTES` will delete until only _BYTES_ have been freed (usual
`KMGT` suffixes). `--print-dead` and `--delete` print total bytes freed. GC
is also influenced by the `keep-outputs` and `keep-derivations` variables
in the Nix configuration file.

Common GC-related options for operations of various Nix commands:

    nix-store --add-root /nix/var/nix/gcroots/PATH COMMAND ...
    nix-store --indirect --add-root PATH           COMMAND ...
    nix-instantiate --add-root ... --indirect ...  # Same opts as nix-store
    nix-build -O PATH ...

The `--indirect` option creates a symlink in `/nix/var/nix/gcroots/auto/`
to _PATH_ (usually outside the store), as does the `-O` option. Renaming
that path will make the symlink to it dangling and thus remove it from the
list of GC roots.


Commands
--------

### Environment Variables

The `nix.sh` (single-user installation) and `nix-daemon.sh` (multi-user
installation) are the nix-supplied sh/bash profiles for `/etc/profile.d/`.

Enviroment variables are listed in [Chapter 21: Common Environment
Variables][nix env] and a section of the `nix-env(1)` manual page. Neither
of these are complete; ▲ below marks ones for which no documentation has
been found. ¶ marks ones set by `{nix,nix-daemon}.sh`. (`nix.sh` refers to
both unless otherwise indicated. The `nix.sh` script appears to be newer
and better written than `nix-daemon.sh`.)

- ¶`PATH`: Prefixed with `$HOME/.nix-profile/bin` by `nix.sh`.
- ¶`MANPATH`: Prefixed with `$HOME/.nix-profile/share/man` by `nix.sh` (but
  not by `nix-daemon.sh`).
- ¶`NIX_SSL_CERT_FILE`
- ▲¶`NIX_PROFILES`: Set by `nix.sh` to a space-separated list of specific
  profiles: `/nix/var/nix/profiles/default $HOME/.nix-profile`. Testing
  shows that these do not seem to be used by `nix-env`.
- ¶`NIX_PATH`: See below.

__NIX_PATH__

`profile.d/nix.sh` does:

    # Append ~/.nix-defexpr/channels to $NIX_PATH so that <nixpkgs>
    # paths work when the user has fetched the Nixpkgs channel.
    export NIX_PATH=${NIX_PATH:+$NIX_PATH:}$HOME/.nix-defexpr/channels

`profile.d/nix-daemon.sh` instead does (linebreaks for readability):

    NIX_PATH="\
      nixpkgs=/nix/var/nix/profiles/per-user/root/channels/nixpkgs\
             :/nix/var/nix/profiles/per-user/root/channels"

Not clear why the `nix-daemon` version is different. Perhaps it's because
it wants to use "system" channels by default in the multi-user
configuration, or perhaps it's just an older script that hasn't been
updated.

### Common Options

Most everything takes `--dry-run` to print what would have been done
instead of doing it. It may also print which paths are being built from
source and which are being  substituted (downloading a binary instead of
building.)

`-v`/`--verbose` and `--quiet` increase and decrease the verbosity level
with each use. The default level is 0 "Errors only"; subsequent ones are 1
"Informational," 2 "Talkative," 3 "Chatty," 4 "Debug," 5 "Vomit."

The _default expression_ used by `nix-env` can be specified with `-f` or
`--file`, which takes a path to a file, directory or HTTP/HTTPS URL; the
default is `~/.nix-defexpr`. If a file, it's loaded; if a directory, the
`default.nix` in it is loaded; if a directory without a `default.nix`, the
files and subdirs under it are loaded as above. All expressions are
combined into a single set; any expressions that are sets are used as is,
but functions are evaluated with the empty set as a parameter.

Essentially this is like importing; two files `foo.nix` and `bar.nix` in a
directory will be evaluated like:

    {
        foo = import ~/.nix-defexpr/foo.nix;
        bar = import ~/.nix-defexpr/bar.nix;
    }

### Useful Commands

    nix-env [--dry-run] [-v] [--quiet] ...      # common options

    sudo nix-daemon --daemon &  # start daemon in docker container
    nix ping-store      # (no args) check if daemon is running and accessible
    nix-env -qa         # Query packages; -a = all (uninstalled too; slow)

    #   Nixpkgs "standard library"
    nix-channel --add https://nixos.org/channels/nixpkgs-unstable
    nix-channel --update

    nix-env -qas        # status of packages

    nix-store --gc --print-roots
    nix-store --gc --print-live

### nix-env

    nix-env [--dry-run] [-v] [--quiet] [-p PATH] ...
    nix-env --switch-profile PATH       # change ~/.nix-profile link,
    nix-env -q [-s] [SEL]               # query
    nix-env [-i|-u|-e] SEL              # install/update/erase

- _PATH_ for profiles is a full path, or relative to CWD, to the profile's
  main symlink. It is created if it doesn't exist.
- _SEL_ is a "selector" regexp, except that the portion of a package name
  after the final hyphen is considered the version, and bare names match
  the latest version of a package.

Common arguments:
* `--dry-run`: print what would be done;
  show what will be built and what will be substituted.
* `-v`, `-q`: change verbose level up/down
* `-p PATH`, `--profile PATH`: Set the _active profile_ for a nix-env run.
  The default is the _current profile_, `~/.nix-profile`.
* `-f PATH`, `--file PATH`: Sets the _active nix expression_ (dir with
  `default.nix` in it) used to obtain derivations. (default `~/.nix-defexpr`)
  May start with `http://` or `https://` to download tarball with single
  top-level dir containing `default.nix`.

Operations on a profile:
* __Query:__ `-q`, `--query`
  * : `-s` for status (`IPS`=installed in current user env, present on
    system, "substitute" available i.e. pre-built binary can be fetched)
* __Install:__ `-i`, `--install` (selector required): creates new user
  environment with this package added (even if same version already
  present—installing again my change filename conflict resolution?).
* __Upgrade__ `-u`, `--upgrade` (selector optional): Replace current
  versions of listed packages (all in env if no selector) with newer
  versions, if available.
* __Erase__: `-e` / `--uninstall` (selector required): remove a package

Profile management commands:
* `-S PATH`/`--switch-profile PATH`: Change the `~/.nix-profile` symlink to
  point to `PATH`. Non-absolute paths are relative to CWD. No validity
  checks are done.
* `--list-generations`
* `-G N`, `--switch-generation N`: Change current generation to _N_.
* `--rollback`: Switch to the highest-numbered generation less than the
  current one.
* `--delete-generations N ...`: Delete given generations. "`old`" will
  delete all non-current generations, `30d` all older than 30 days, and
  `+N` to keep the last _N_. Users must use this reguarly for GC to be
  effective.

### nix-store

    nix-store [--dry-run] --realise /nix/store/…
    nix-store --query QTYPE /nix/store/….drv
    #   Add --use-output to above to query output path of derivation instead.

    QTYPE:    --outputs | --requisites | -R | --references
            | --referrers | --referrers-closure | --deriver | -d
            | --graph | --tree | --binding name | -b name
            | --hash | --size | --roots


Misc
----

All packages below are available in Nixpkgs unless noted otherwise.

- `dockerTools` helps automate [building Docker images][docker].
- [Niv] does Nix package dependency management for development
  repos that use tools from Nixpkgs, like a Nix version of
  `requirements.txt` or NPM.
- [Home Manager][home-manager] provides a system for managing a user
  environment with Nix and Nixpkgs.



<!-------------------------------------------------------------------->
[NixOS]: https://nixos.org/manual/nixos/stable/
[Nix]: https://nixos.org/manual/nix/stable/
[Nixpkgs]: https://nixos.org/manual/nixpkgs/stable/

<!-- Manual deep links -->
[bc]: https://wiki.nixos.org/wiki/Binary_Cache
[cachix]: https://docs.cachix.org/
[channels]: https://wiki.nixos.org/wiki/Nix_channels
[nix #!]: https://nixos.org/manual/nix/stable/#use-as-a-interpreter
[nix env]: https://nixos.org/manual/nix/stable/#sec-common-env
[nix instbin]: https://nixos.org/manual/nix/stable/#ch-installing-binary
[nix instsrc]: https://nixos.org/manual/nix/stable/#ch-installing-source
[nix expr]: https://nixos.org/manual/nix/stable/#ch-expression-language

[arch]: https://wiki.archlinux.org/title/Nix
[derivation]: https://nixos.org/guides/nix-pills/our-first-derivation.html

[lucperkins]: https://lucperkins.dev/blog/nix-channel/

[docker]: https://nix.dev/tutorials/building-and-running-docker-images
[home-manager]: https://github.com/nix-community/home-manager
[niv]: https://github.com/nmattia/niv
